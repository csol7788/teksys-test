# simple AWS REST API service

This repository holds Terraform IaC to stand up a simple REST API solution using the following technologies:

- AWS API Gateway
- Lambda

Folder Stucture:

- .gh/workflows holds the CICD pipelines (rename the .gh folder to .github to enable workflows within your repo.)
- backend_files holds configuration information used to initialize Terraform with an S3 backend
- lambda_code holds some simple python code to retrieve the date and time and return it from the API
- lambda_packages is a temporary folder generated by terraform to hold the python package to be attached to the lambda
- scripts holds any scripts used by either Terraform or GitHub Workflows
- terraform holds individual terraform code stacks

Pre-Requisites:

It is expected that an AWS account will already exist, and that it has been commissioned with the following:

- S3 TFSTATE bucket
- DynamoDB State file locking table
- KMS key to encrypt the state file

The following GitHub secrets must be generated:

- AWS_ACCESS_KEY
- AWS_SECRET_ACCESS_KEY

The following GitHub variable must be generated:

- AWS_ENV

The AWS Keys are used to configure AWS access on the GitHub Runner.
The AWS_ENV is used to select the appropriate backend_file configuration. This could be replaced at a later date with a more dynamic configuration which builds the environment(s) based on the name of the branch being worked on allowing for feature branches.

Pipelines:

Due to the simplicity of the application I've chosen to implement the pipelines using the TRUNK Development method, essentially meaning that the application is tested significantly on feature branches prior to any code being allowed to merge into the MAIN branch. Release branches are not required and MAIN will immediately be pushed into the production environment. This method allows for small increments in code to be rolled out at a greater rate.

- ci-pipeline.yml: is triggered when a new pull request is generated. It performs the following actions:
    - Testing: Terraform formatting, linting, and Checkov to ensure the code is of a set standard.
    - Terraform: performs plan, deployment and at the end of the run it will teardown the built infrastructure
    - SmokeTesting: when the API is built and running it performs a simple check to ensure the gateway is responsive.
- cd-pipeline.yml: is triggered when a branch is merged into 'origin/main'
    - Terraform: performs a plan followed by a deployment to the production environment.
    - SmokeTests: These are executed again to ensure the production environment has not encountered any issues post deployment of new code.
    - If you are hosting multiple environments then it should be adjusted to deploy out each environment in order without being able to deploy to the next tier until a clean bill of health has been given to the current deployment.

